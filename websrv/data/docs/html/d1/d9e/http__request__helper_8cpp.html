<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WebServer: websrv/srcs/http_request_helper.cpp File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">WebServer
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_b90e5ee102960250936331e6399bc82d.html">websrv</a></li><li class="navelem"><a class="el" href="../../dir_1b85a2026b92d7b9d58d07dea8a171af.html">srcs</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">http_request_helper.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="../../da/d2b/http__enum__codes_8hpp_source.html">http_enum_codes.hpp</a>&quot;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;set&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a411f70b0adb50fb351494b96143fb0ce" id="r_a411f70b0adb50fb351494b96143fb0ce"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a411f70b0adb50fb351494b96143fb0ce">http_status_description</a> (<a class="el" href="../../da/d2b/http__enum__codes_8hpp.html#a991546140b16a555c1d90caffcb0e390">e_http_sts</a> code)</td></tr>
<tr class="memdesc:a411f70b0adb50fb351494b96143fb0ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a standard message for a http code.  <br /></td></tr>
<tr class="separator:a411f70b0adb50fb351494b96143fb0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ec24b7da0c90f7e3e7a4e4b068a995" id="r_ad0ec24b7da0c90f7e3e7a4e4b068a995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d2b/http__enum__codes_8hpp.html#a40092c1e03ca1f11758a2ddb4708958a">t_methods</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0ec24b7da0c90f7e3e7a4e4b068a995">parse_method</a> (const std::string &amp;method)</td></tr>
<tr class="memdesc:ad0ec24b7da0c90f7e3e7a4e4b068a995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses an HTTP method string and returns the corresponding method mask.  <br /></td></tr>
<tr class="separator:ad0ec24b7da0c90f7e3e7a4e4b068a995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901157cdb2c9069d0f08cab6b799eb60" id="r_a901157cdb2c9069d0f08cab6b799eb60"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a901157cdb2c9069d0f08cab6b799eb60">create_mime_types</a> ()</td></tr>
<tr class="memdesc:a901157cdb2c9069d0f08cab6b799eb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a map of file extensions to MIME types.  <br /></td></tr>
<tr class="separator:a901157cdb2c9069d0f08cab6b799eb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e2cc49561a109eab7a3c41845ef0c7" id="r_a83e2cc49561a109eab7a3c41845ef0c7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83e2cc49561a109eab7a3c41845ef0c7">get_mime_type</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a83e2cc49561a109eab7a3c41845ef0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the MIME type based on the file extension.  <br /></td></tr>
<tr class="separator:a83e2cc49561a109eab7a3c41845ef0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac27fe9a0fc4b3f5222a36edb6b54dae" id="r_aac27fe9a0fc4b3f5222a36edb6b54dae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac27fe9a0fc4b3f5222a36edb6b54dae">valid_mime_type</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:aac27fe9a0fc4b3f5222a36edb6b54dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the MIME type based on the file extension.  <br /></td></tr>
<tr class="separator:aac27fe9a0fc4b3f5222a36edb6b54dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775a50523b2792565271f85e8d63d72b" id="r_a775a50523b2792565271f85e8d63d72b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a775a50523b2792565271f85e8d63d72b">black_list_extension</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a775a50523b2792565271f85e8d63d72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given file path has a disallowed extension.  <br /></td></tr>
<tr class="separator:a775a50523b2792565271f85e8d63d72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5671fb0d0191f86588463c6e29911fa6" id="r_a5671fb0d0191f86588463c6e29911fa6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5671fb0d0191f86588463c6e29911fa6">replace_template</a> (std::string content, const std::string &amp;key, const std::string &amp;value)</td></tr>
<tr class="memdesc:a5671fb0d0191f86588463c6e29911fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of a key in the content with a given value.  <br /></td></tr>
<tr class="separator:a5671fb0d0191f86588463c6e29911fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8d6608f966337610cf3eaf4b305d7e" id="r_a7d8d6608f966337610cf3eaf4b305d7e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d8d6608f966337610cf3eaf4b305d7e">clean_host</a> (std::string &amp;host_to_clean)</td></tr>
<tr class="memdesc:a7d8d6608f966337610cf3eaf4b305d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up a host string by removing protocol prefixes, port numbers, and path segments.  <br /></td></tr>
<tr class="separator:a7d8d6608f966337610cf3eaf4b305d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cd1ba4270d9f786fe644a5ac82ba78" id="r_a34cd1ba4270d9f786fe644a5ac82ba78"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34cd1ba4270d9f786fe644a5ac82ba78">normalize_host</a> (const std::string &amp;host)</td></tr>
<tr class="separator:a34cd1ba4270d9f786fe644a5ac82ba78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1405af62ae4c7c679726a051ba7bc3a0" id="r_a1405af62ae4c7c679726a051ba7bc3a0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1405af62ae4c7c679726a051ba7bc3a0">get_header_value</a> (std::string &amp;haystack, std::string needle, const std::string &amp;sep)</td></tr>
<tr class="memdesc:a1405af62ae4c7c679726a051ba7bc3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the value of a specific HTTP header field.  <br /></td></tr>
<tr class="separator:a1405af62ae4c7c679726a051ba7bc3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93fb754820f510dc2d17f64ee15a773" id="r_ab93fb754820f510dc2d17f64ee15a773"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab93fb754820f510dc2d17f64ee15a773">is_cgi</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:ab93fb754820f510dc2d17f64ee15a773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a file is a CGI script based on its extension.  <br /></td></tr>
<tr class="separator:ab93fb754820f510dc2d17f64ee15a773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6108cd0eb7f707a1e58ff83b6c8a3a" id="r_add6108cd0eb7f707a1e58ff83b6c8a3a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add6108cd0eb7f707a1e58ff83b6c8a3a">end_of_header_system</a> (std::string &amp;header)</td></tr>
<tr class="memdesc:add6108cd0eb7f707a1e58ff83b6c8a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the end of the HTTP header in a string.  <br /></td></tr>
<tr class="separator:add6108cd0eb7f707a1e58ff83b6c8a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a775a50523b2792565271f85e8d63d72b" name="a775a50523b2792565271f85e8d63d72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775a50523b2792565271f85e8d63d72b">&#9670;&#160;</a></span>black_list_extension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool black_list_extension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a given file path has a disallowed extension. </p>
<p>This function determines whether the file extension of the provided path is part of a predefined blacklist of disallowed extensions. If the extension is blacklisted, the function returns <code>true</code>; otherwise, it returns <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A string representing the file path to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the file's extension is blacklisted; otherwise, <code>false</code>.</dd></dl>
<ul>
<li>The function uses a static set of disallowed extensions, which is initialized on the first call. The blacklist includes extensions such as <code>.exe</code>, <code>.bat</code>, <code>.sh</code>, <code>.php</code>, <code>.pl</code>, and <code>.py</code>.</li>
<li>The function extracts the file extension by locating the last <code>.</code> character in the file path and comparing the substring to the blacklist.</li>
<li>If no <code>.</code> character is found in the path, or if the extension is not in the blacklist, the function returns <code>false</code>. </li>
</ul>

</div>
</div>
<a id="a7d8d6608f966337610cf3eaf4b305d7e" name="a7d8d6608f966337610cf3eaf4b305d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8d6608f966337610cf3eaf4b305d7e">&#9670;&#160;</a></span>clean_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string clean_host </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>host_to_clean</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleans up a host string by removing protocol prefixes, port numbers, and path segments. </p>
<p>This function processes a host string to extract the clean hostname by:</p><ol type="1">
<li>Removing any leading protocol prefixes (e.g., "http://").</li>
<li>Stripping port numbers appended with a colon (e.g., ":8080").</li>
<li>Removing any path segments following the hostname (e.g., "/path/to/resource").</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host_to_clean</td><td>A reference to the original host string to be cleaned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A cleaned host string containing only the hostname without prefixes, ports, or paths.</dd></dl>
<ul>
<li>The function works step by step:<ol type="1">
<li>Finds and removes the <code>//</code> sequence, which typically appears in protocol prefixes like "http://".</li>
<li>Removes anything after the last <code>:</code> to discard port numbers.</li>
<li>Iteratively removes any leading <code>/</code> characters and paths.</li>
</ol>
</li>
<li>If the input string does not contain these patterns, it is returned as-is.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This function assumes the input string follows a valid URL-like format.</li>
<li>The function performs string operations such as <code>find</code> and <code>substr</code>, which are safe in C++98. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a901157cdb2c9069d0f08cab6b799eb60" name="a901157cdb2c9069d0f08cab6b799eb60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901157cdb2c9069d0f08cab6b799eb60">&#9670;&#160;</a></span>create_mime_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, std::string &gt; create_mime_types </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a map of file extensions to MIME types. </p>
<p>This method generates a map that associates common file extensions (e.g., ".html", ".jpg") with their corresponding MIME types (e.g., "text/html", "image/jpeg"). The map is used to determine the <code>Content-Type</code> header when serving files.</p>
<ul>
<li>The method ensures that the map is initialized only once, using a static map to avoid recreating the map on each call. If additional MIME types are required, they can be added to the map.</li>
<li>Common MIME types such as <code>text/html</code>, <code>application/javascript</code>, and <code>image/jpeg</code> are included.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>std::map&lt;std::string, std::string&gt; A map that associates file extensions with their MIME types. </dd></dl>

</div>
</div>
<a id="add6108cd0eb7f707a1e58ff83b6c8a3a" name="add6108cd0eb7f707a1e58ff83b6c8a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6108cd0eb7f707a1e58ff83b6c8a3a">&#9670;&#160;</a></span>end_of_header_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t end_of_header_system </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>header</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the end of the HTTP header in a string. </p>
<p>This function locates the end of the HTTP header in the given string by searching for the sequence <code>\\r\\n\\r\\n</code> or <code>\\n\\n</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>The HTTP header string to be analyzed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position where the header ends. If no header end is found, returns <code>std::string::npos</code>. </dd></dl>

</div>
</div>
<a id="a1405af62ae4c7c679726a051ba7bc3a0" name="a1405af62ae4c7c679726a051ba7bc3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1405af62ae4c7c679726a051ba7bc3a0">&#9670;&#160;</a></span>get_header_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string get_header_value </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>haystack</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>needle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>sep</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the value of a specific HTTP header field. </p>
<p>This method searches the provided header string for a specific key and returns the associated value. The search is case-insensitive, and it assumes the format <code>key: value</code>.</p>
<ul>
<li>The method first converts the key and the header string to lowercase for a case-insensitive search.</li>
<li>The value is extracted by searching for the next occurrence of <code>\r\n</code>, which signifies the end of the value.</li>
<li>If the key is not found, the method returns an empty string.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>The HTTP Header format string to be searched over it. </td></tr>
    <tr><td class="paramname">needle</td><td>The key for which the value is to be retrieved (e.g., "content-type"). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The value associated with the key, or an empty string if the key is not found. </dd></dl>

</div>
</div>
<a id="a83e2cc49561a109eab7a3c41845ef0c7" name="a83e2cc49561a109eab7a3c41845ef0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e2cc49561a109eab7a3c41845ef0c7">&#9670;&#160;</a></span>get_mime_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string get_mime_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the MIME type based on the file extension. </p>
<p>This method looks up the MIME type corresponding to the file extension in the provided path. If the file extension is recognized, the associated MIME type is returned. If the extension is not recognized, it defaults to <code>text/plain</code>.</p>
<ul>
<li>The method extracts the file extension by searching for the last '.' character in the path.</li>
<li>If the extension is found in the <code>mime_types</code> map, the corresponding MIME type is returned.</li>
<li>If no recognized extension is found, the default MIME type <code>text/plain</code> is returned.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file system path to the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The MIME type corresponding to the file extension, or <code>text/plain</code> if not found. </dd></dl>

</div>
</div>
<a id="a411f70b0adb50fb351494b96143fb0ce" name="a411f70b0adb50fb351494b96143fb0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411f70b0adb50fb351494b96143fb0ce">&#9670;&#160;</a></span>http_status_description()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string http_status_description </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d2b/http__enum__codes_8hpp.html#a991546140b16a555c1d90caffcb0e390">e_http_sts</a></td>          <td class="paramname"><span class="paramname"><em>code</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a standard message for a http code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>http code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>short standard message associated with the http code. </dd></dl>

</div>
</div>
<a id="ab93fb754820f510dc2d17f64ee15a773" name="ab93fb754820f510dc2d17f64ee15a773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93fb754820f510dc2d17f64ee15a773">&#9670;&#160;</a></span>is_cgi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_cgi </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a file is a CGI script based on its extension. </p>
<p>This function checks whether the given filename corresponds to a CGI script by looking at its extension. It checks for extensions such as <code>.py</code> and <code>.php</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the filename corresponds to a CGI script, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a34cd1ba4270d9f786fe644a5ac82ba78" name="a34cd1ba4270d9f786fe644a5ac82ba78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34cd1ba4270d9f786fe644a5ac82ba78">&#9670;&#160;</a></span>normalize_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string normalize_host </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>host</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0ec24b7da0c90f7e3e7a4e4b068a995" name="ad0ec24b7da0c90f7e3e7a4e4b068a995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ec24b7da0c90f7e3e7a4e4b068a995">&#9670;&#160;</a></span>parse_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d2b/http__enum__codes_8hpp.html#a40092c1e03ca1f11758a2ddb4708958a">t_methods</a> parse_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>method</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses an HTTP method string and returns the corresponding method mask. </p>
<p>This function maps a given HTTP method string (e.g., "GET", "POST") to its corresponding predefined method mask (<code>t_methods</code>). If the method is not recognized, it returns 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>A string representing the HTTP method to parse (e.g., "GET", "POST"). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding <code>t_methods</code> mask if the method is recognized; otherwise, returns 0.</dd></dl>
<ul>
<li>The method uses a static map to store the mapping between HTTP method strings and their corresponding bitmask constants (e.g., <code>MASK_METHOD_GET</code> for "GET").</li>
<li>The map is initialized only once, ensuring efficiency for subsequent calls.</li>
<li>If the provided method string is not found in the map, the function returns 0, indicating an unrecognized or unsupported method.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Supported methods include: "GET", "POST", "DELETE", "PUT", "HEAD", "OPTIONS", and "PATCH".</li>
<li>This function is case-sensitive. Ensure that the input method string matches the expected format (e.g., "GET" must be uppercase). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5671fb0d0191f86588463c6e29911fa6" name="a5671fb0d0191f86588463c6e29911fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5671fb0d0191f86588463c6e29911fa6">&#9670;&#160;</a></span>replace_template()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_template </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>content</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all occurrences of a key in the content with a given value. </p>
<p>This method searches the provided content for all occurrences of the key and replaces each one with the specified value. It returns the modified content with all replacements made.</p>
<ul>
<li>The method iterates through the content, finding each occurrence of the key using <code>std::string::find()</code>.</li>
<li>For each occurrence, it replaces the key with the value using <code>std::string::replace()</code>.</li>
<li>If the value contains the key (which could cause an infinite loop), the method does not perform any replacements.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>The content in which to perform the replacements (e.g., HTML file content). </td></tr>
    <tr><td class="paramname">key</td><td>The key to search for in the content (e.g., "{error_code}"). </td></tr>
    <tr><td class="paramname">value</td><td>The value to replace the key with (e.g., "404"). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The content with all occurrences of the key replaced by the value. </dd></dl>

</div>
</div>
<a id="aac27fe9a0fc4b3f5222a36edb6b54dae" name="aac27fe9a0fc4b3f5222a36edb6b54dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac27fe9a0fc4b3f5222a36edb6b54dae">&#9670;&#160;</a></span>valid_mime_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool valid_mime_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate the MIME type based on the file extension. </p>
<p>This method looks up the MIME type corresponding to the file extension in the provided path. If the file extension is recognized, true is returned. If the extension is not recognized, false</p>
<ul>
<li>The method extracts the file extension by searching for the last '.' character in the path.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file system path to the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if a MIME type is recognized, false otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
